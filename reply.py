# -*- coding: utf-8 -*-
"""Untitled29.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1iqB4ZXtCMCNYrhpF_MgUOQ84RVOn8AT0
"""

from collections import deque

# Define is_valid function to check if coordinates are within bounds
def is_valid(x, y, W, H):
    return 0 <= x < W and 0 <= y < H

# Breadth-First Search (BFS) function
# Breadth-First Search (BFS) function
def bfs(grid, start, end):
    visited = set()
    queue = deque([(tuple(start), [])])  # Convert start to a tuple

    while queue:
        current, path = queue.popleft()
        x, y = current

        if current == end:
            return path  # Return the path if the end point is reached

        if current not in visited:
            visited.add(current)
            # Iterate over neighbors of the current cell
            for dx, dy, _, _ in grid[x][y]:
                new_x, new_y = x + dx, y + dy
                if is_valid(new_x, new_y, len(grid), len(grid[0])):
                    # Append the new position and the updated path to the queue
                    queue.append(((new_x, new_y), path + [(new_x, new_y)]))
    return None  # Return None if no path is found


# Function to parse the input file
def parse_input(filename):
    with open(filename, 'r',encoding='utf-8-sig') as f:
        W, H, GN, SM, TL = map(int, f.readline().split())
        golden_points = [list(map(int, f.readline().split())) for _ in range(GN)]
        silver_points = [list(map(int, f.readline().split())) for _ in range(SM)]
        tiles = [list(f.readline().split()) for _ in range(TL)]
    return W, H, golden_points, silver_points, tiles

# Function to get the movement direction based on tile ID
def get_direction(tile_id):
    if tile_id == "3":
        return 1, 0  # From left to right
    elif tile_id == "5":
        return 0, 1  # From down to right
    elif tile_id == "6":
        return -1, 0  # From left to down
    elif tile_id == "7":
        return 1, 0  # From left to right
    elif tile_id == "9":
        return 1, -1  # From up to right
    elif tile_id == "96":
        return -1, 1  # From left to down, From up to right
    elif tile_id == "A":
        return 0, -1  # From left to up
    elif tile_id == "A5":
        return 1, 1  # From left to up, From down to right
    elif tile_id == "B":
        return 1, 1  # From left to right, From left to up, From up to right
    elif tile_id == "C":
        return 0, 1  # From up to down
    elif tile_id == "C3":
        return 1, 1  # From left to right, From up to down
    elif tile_id == "D":
        return 0, 1  # From up to down, From up to right, From down to right
    elif tile_id == "E":
        return -1, -1  # From left to up, From left to down, From up to down
    elif tile_id == "F":
        return 1, 1  # From left to right, From left to down, From left to up, From up to down, From down to right, From up to right
    else:
        return 0, 0  # Default case, no movement



# Function to create grid with tile information
def get_grid(tiles, W, H):
    # Initialize the grid with empty lists
    grid = [[[] for _ in range(H)] for _ in range(W)]

    # Iterate through the tiles and populate the grid
    for tile_id, cost, count in tiles:
        for _ in range(int(count)):
            for x in range(W):
                for y in range(H):
                    dx, dy = get_direction(tile_id)
                    grid[x][y].append((dx, dy, 0, int(cost)))  # Add tile information to grid
    return grid



# Function to check if coordinates are within bounds
def is_valid(x, y, W, H):
    return 0 <= x < W and 0 <= y < H

# Function to find shortest paths between all pairs of golden points
def find_shortest_paths(grid, golden_points):
    shortest_paths = {}
    for i, start in enumerate(golden_points):
        for j, end in enumerate(golden_points):
            if i != j:
                path = bfs(grid, start, end)
                if path:
                    shortest_paths[(i, j)] = path
    return shortest_paths





# Main function
# Main function
def main(input_file, output_file):
    # Parse input file
    W, H, golden_points, _, tiles = parse_input(input_file)

    # Create grid with tiles information
    grid = get_grid(tiles, W, H)

    # Find shortest paths between all pairs of golden points
    shortest_paths = find_shortest_paths(grid, golden_points)

    # Write shortest paths to output file
    with open(output_file, 'a') as f:
        for (start_x, start_y), (end_x, end_y) in shortest_paths:
            start = (start_x, start_y)
            end = (end_x, end_y)
            path = shortest_paths[(start, end)]
            f.write("Shortest path between golden points {} and {}: {}\n".format(start, end, path))

# Run the main function
if __name__ == "__main__":
    main("/content/00-trailer.txt", "output.txt")

